/**
 * roomMic 2.0 - Centralized Audio Streaming
 * All audio streams to the host's speakers only
 */

// Application State
const AppState = {
    peer: null,
    localStream: null,
    audioContext: null,
    audioDestination: null,
    connections: new Map(),
    gainNodes: new Map(),
    currentRoom: null,
    isHost: false,
    isMicActive: true,
    participantCount: 0
};

// DOM Elements
const Elements = {
    // Screens
    mainScreen: document.getElementById('main-screen'),
    createScreen: document.getElementById('create-screen'),
    joinScreen: document.getElementById('join-screen'),
    sessionScreen: document.getElementById('session-screen'),
    
    // Buttons
    btnCreateRoom: document.getElementById('btn-create-room'),
    btnJoinRoom: document.getElementById('btn-join-room'),
    btnBackCreate: document.getElementById('btn-back-create'),
    btnBackJoin: document.getElementById('btn-back-join'),
    btnCopyCode: document.getElementById('btn-copy-code'),
    btnStartHosting: document.getElementById('btn-start-hosting'),
    btnJoinConfirm: document.getElementById('btn-join-confirm'),
    btnToggleMic: document.getElementById('btn-toggle-mic'),
    btnLeaveRoom: document.getElementById('btn-leave-room'),
    
    // Display Elements
    roomCode: document.getElementById('room-code'),
    joinCodeInput: document.getElementById('join-code-input'),
    sessionTitle: document.getElementById('session-title'),
    participantCount: document.getElementById('participant-count'),
    connectionStatus: document.getElementById('connection-status'),
    currentRoomCode: document.getElementById('current-room-code'),
    userRole: document.getElementById('user-role'),
    volumeBars: document.querySelectorAll('.volume-bar'),
    
    // Audio & Toast
    audioOutput: document.getElementById('audio-output'),
    statusToast: document.getElementById('status-toast'),
    statusMessage: document.getElementById('status-message')
};

// Utility Functions
const Utils = {
    generateRoomCode() {
        return Math.floor(1000 + Math.random() * 9000).toString();
    },

    showScreen(screenName) {
        document.querySelectorAll('.screen').forEach(screen => {
            screen.classList.remove('active');
        });
        Elements[screenName + 'Screen'].classList.add('active');
    },

    showToast(message, duration = 3000) {
        Elements.statusMessage.textContent = message;
        Elements.statusToast.classList.add('show');
        
        setTimeout(() => {
            Elements.statusToast.classList.remove('show');
        }, duration);
    },

    updateConnectionStatus(status, className = '') {
        Elements.connectionStatus.textContent = status;
        Elements.connectionStatus.className = 'status ' + className;
    },

    updateParticipantCount(count) {
        AppState.participantCount = count;
        Elements.participantCount.textContent = `砖转转驻: ${count}`;
    },

    updateVolumeIndicator(level) {
        const activeCount = Math.floor((level / 100) * Elements.volumeBars.length);
        Elements.volumeBars.forEach((bar, index) => {
            bar.classList.toggle('active', index < activeCount);
        });
    },

    copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
            Utils.showToast('拽 注转拽!');
        }).catch(() => {
            Utils.showToast(' 转 注转拽', 2000);
        });
    }
};

// Audio Management
const AudioManager = {
    async initializeAudioContext() {
        if (AppState.audioContext) {
            await AppState.audioContext.close();
        }

        AppState.audioContext = new (window.AudioContext || window.webkitAudioContext)({
            latencyHint: 'interactive',  // More compatible latency setting
            sampleRate: 48000           // Standard sample rate
        });

        AppState.audioDestination = AppState.audioContext.createMediaStreamDestination();
        Elements.audioOutput.srcObject = AppState.audioDestination.stream;
        
        try {
            await Elements.audioOutput.play();
            console.log('Audio context initialized successfully');
        } catch (e) {
            console.warn('Auto-play prevented, user interaction required');
        }
    },

    async requestMicrophone() {
        try {
            AppState.localStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,  // Re-enabled for better compatibility
                    noiseSuppression: true,  // Re-enabled for better quality
                    autoGainControl: true,   // Re-enabled for consistent volume
                    latency: 0.01,           // More conservative latency
                    sampleRate: 48000,       // Standard sample rate for better compatibility
                    channelCount: 1
                }
            });
            console.log('Microphone access granted');
            return true;
        } catch (error) {
            console.error('Microphone access denied:', error);
            Utils.showToast(' 转 砖转 拽专驻');
            return false;
        }
    },

    addLocalAudioToMix() {
        if (!AppState.audioContext || !AppState.localStream || !AppState.isHost) return;

        const source = AppState.audioContext.createMediaStreamSource(AppState.localStream);
        const gainNode = AppState.audioContext.createGain();
        gainNode.gain.value = 0.7; // Host hears themselves at lower volume
        
        source.connect(gainNode);
        gainNode.connect(AppState.audioDestination);
        
        AppState.gainNodes.set('local', { source, gainNode });
    },

    addRemoteAudioToMix(peerId, stream) {
        if (!AppState.audioContext || !AppState.isHost) return;

        const source = AppState.audioContext.createMediaStreamSource(stream);
        const gainNode = AppState.audioContext.createGain();
        gainNode.gain.value = 1.0;
        
        source.connect(gainNode);
        gainNode.connect(AppState.audioDestination);
        
        AppState.gainNodes.set(peerId, { source, gainNode });
    },

    removeAudioFromMix(peerId) {
        const audioNodes = AppState.gainNodes.get(peerId);
        if (audioNodes) {
            audioNodes.source.disconnect();
            audioNodes.gainNode.disconnect();
            AppState.gainNodes.delete(peerId);
        }
    },

    toggleMicrophone() {
        if (!AppState.localStream) return;

        const audioTrack = AppState.localStream.getAudioTracks()[0];
        audioTrack.enabled = !audioTrack.enabled;
        AppState.isMicActive = audioTrack.enabled;

        const btn = Elements.btnToggleMic;
        const icon = btn.querySelector('.btn-icon');
        const text = btn.querySelector('.btn-text');

        if (AppState.isMicActive) {
            btn.classList.add('active');
            icon.textContent = '';
            text.textContent = '拽专驻 驻注';
            Utils.showToast('拽专驻 驻注');
        } else {
            btn.classList.remove('active');
            icon.textContent = '';
            text.textContent = '拽专驻 砖转拽';
            Utils.showToast('拽专驻 砖转拽');
        }
    },

    cleanup() {
        // Stop all audio tracks
        if (AppState.localStream) {
            AppState.localStream.getTracks().forEach(track => track.stop());
            AppState.localStream = null;
        }

        // Disconnect all audio nodes
        AppState.gainNodes.forEach((nodes, peerId) => {
            AudioManager.removeAudioFromMix(peerId);
        });

        // Close audio context
        if (AppState.audioContext) {
            AppState.audioContext.close();
            AppState.audioContext = null;
        }

        // Clear audio output
        Elements.audioOutput.srcObject = null;
    }
};

// WebRTC Connection Management
const ConnectionManager = {
    async startAsHost(roomCode) {
        AppState.peer = new Peer(roomCode, {
            debug: 1,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478' },
                    { urls: 'stun:stun.cloudflare.com:3478' }
                ],
                sdpSemantics: 'unified-plan',
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            }
        });

        AppState.peer.on('open', () => {
            Utils.updateConnectionStatus('转 砖转转驻...', 'connecting');
            AudioManager.initializeAudioContext();
            AudioManager.addLocalAudioToMix();
            console.log('Host peer opened with ID:', roomCode);
        });

        AppState.peer.on('call', (incomingCall) => {
            const peerId = incomingCall.peer;
            console.log('Incoming call from:', peerId);
            Utils.showToast(`砖转转祝 转专: ${peerId.substring(0, 8)}...`);
            
            // Answer with local stream
            incomingCall.answer(AppState.localStream);
            AppState.connections.set(peerId, incomingCall);

            incomingCall.on('stream', (remoteStream) => {
                console.log('Received stream from participant:', peerId);
                AudioManager.addRemoteAudioToMix(peerId, remoteStream);
                Utils.updateParticipantCount(AppState.connections.size);
                Utils.updateConnectionStatus('砖专 ', 'connected');
                Utils.showToast(`砖转转祝 爪专祝! (${AppState.connections.size} 砖转转驻)`);
            });

            incomingCall.on('close', () => {
                console.log('Call closed for participant:', peerId);
                ConnectionManager.handleParticipantDisconnection(peerId);
            });

            incomingCall.on('error', (error) => {
                console.error('Call error for participant:', peerId, error);
                ConnectionManager.handleParticipantDisconnection(peerId);
            });
        });

        AppState.peer.on('error', (error) => {
            console.error('Host peer error:', error);
            Utils.updateConnectionStatus('砖转 专', 'error');
            Utils.showToast('砖 爪专转 专');
        });

        AppState.peer.on('disconnected', () => {
            console.log('Host peer disconnected, attempting reconnection...');
            Utils.updateConnectionStatus('转专 砖...', 'connecting');
            setTimeout(() => {
                if (AppState.peer && !AppState.peer.destroyed) {
                    AppState.peer.reconnect();
                }
            }, 1000);
        });
    },

    async startAsParticipant(roomCode) {
        AppState.peer = new Peer(undefined, {
            debug: 1,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:global.stun.twilio.com:3478' },
                    { urls: 'stun:stun.cloudflare.com:3478' }
                ],
                sdpSemantics: 'unified-plan',
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            }
        });

        AppState.peer.on('open', (myPeerId) => {
            console.log('Participant peer opened with ID:', myPeerId);
            Utils.updateConnectionStatus('转专 ...', 'connecting');
            
            setTimeout(() => {
                console.log('Calling host with room code:', roomCode);
                const call = AppState.peer.call(roomCode, AppState.localStream);
                
                if (!call) {
                    Utils.updateConnectionStatus(' 爪 ', 'error');
                    Utils.showToast(' 爪 专 注 拽 ');
                    return;
                }

                AppState.connections.set(roomCode, call);

                call.on('stream', (remoteStream) => {
                    console.log('Received stream from host');
                    // Participants don't hear anything - audio goes to host only
                    Utils.updateConnectionStatus('专 ', 'connected');
                    Utils.showToast('专 爪!  砖注 转');
                });

                call.on('close', () => {
                    console.log('Call to host closed');
                    Utils.updateConnectionStatus('专 住专', 'error');
                    Utils.showToast('专  住专');
                });

                call.on('error', (error) => {
                    console.error('Call to host error:', error);
                    Utils.updateConnectionStatus('砖转 专', 'error');
                    Utils.showToast('砖 专 ');
                });
            }, 500); // Small delay to ensure peer is ready
        });

        AppState.peer.on('error', (error) => {
            console.error('Participant peer error:', error);
            if (error.type === 'peer-unavailable') {
                Utils.updateConnectionStatus('  ', 'error');
                Utils.showToast(' 爪 专 注 拽 ');
            } else if (error.type === 'network') {
                Utils.updateConnectionStatus('注转 专砖转', 'error');
                Utils.showToast('注转 专 专');
            } else {
                Utils.updateConnectionStatus('砖转 专', 'error');
                Utils.showToast('砖 转专转');
            }
        });

        AppState.peer.on('disconnected', () => {
            console.log('Participant peer disconnected, attempting reconnection...');
            Utils.updateConnectionStatus('转专 砖...', 'connecting');
            setTimeout(() => {
                if (AppState.peer && !AppState.peer.destroyed) {
                    AppState.peer.reconnect();
                }
            }, 1000);
        });
    },

    handleParticipantDisconnection(peerId) {
        AudioManager.removeAudioFromMix(peerId);
        AppState.connections.delete(peerId);
        Utils.updateParticipantCount(AppState.connections.size);
        Utils.showToast(`砖转转祝 注 (${AppState.connections.size} 砖转转驻)`);
        
        if (AppState.connections.size === 0) {
            Utils.updateConnectionStatus('转 砖转转驻...', 'connecting');
        }
    },

    cleanup() {
        // Close all connections
        AppState.connections.forEach((connection) => {
            connection.close();
        });
        AppState.connections.clear();

        // Destroy peer
        if (AppState.peer) {
            AppState.peer.destroy();
            AppState.peer = null;
        }

        // Reset state
        AppState.currentRoom = null;
        AppState.isHost = false;
        AppState.participantCount = 0;
    }
};

// Event Handlers
const EventHandlers = {
    // Navigation
    createRoom() {
        AppState.currentRoom = Utils.generateRoomCode();
        AppState.isHost = true;
        Elements.roomCode.textContent = AppState.currentRoom;
        Utils.showScreen('create');
    },

    joinRoom() {
        Elements.joinCodeInput.value = '';
        Utils.showScreen('join');
    },

    backToMain() {
        ConnectionManager.cleanup();
        AudioManager.cleanup();
        Utils.showScreen('main');
    },

    copyRoomCode() {
        Utils.copyToClipboard(AppState.currentRoom);
    },

    // Session Management
    async startHosting() {
        const micGranted = await AudioManager.requestMicrophone();
        if (!micGranted) return;

        Elements.sessionTitle.textContent = '  专';
        Elements.currentRoomCode.textContent = AppState.currentRoom;
        Elements.userRole.textContent = '';
        
        Utils.showScreen('session');
        Utils.updateConnectionStatus('转...', 'connecting');
        
        await ConnectionManager.startAsHost(AppState.currentRoom);
    },

    async joinConfirm() {
        const roomCode = Elements.joinCodeInput.value.trim();
        if (!roomCode || roomCode.length !== 4) {
            Utils.showToast('砖  拽  4 住驻专转');
            return;
        }

        const micGranted = await AudioManager.requestMicrophone();
        if (!micGranted) return;

        AppState.currentRoom = roomCode;
        AppState.isHost = false;
        
        Elements.sessionTitle.textContent = ' 砖转转祝';
        Elements.currentRoomCode.textContent = roomCode;
        Elements.userRole.textContent = '砖转转祝';
        
        Utils.showScreen('session');
        Utils.updateConnectionStatus('转专...', 'connecting');
        
        await ConnectionManager.startAsParticipant(roomCode);
    },

    toggleMicrophone() {
        AudioManager.toggleMicrophone();
    },

    leaveRoom() {
        ConnectionManager.cleanup();
        AudioManager.cleanup();
        Utils.showScreen('main');
        Utils.showToast('注转 转 专');
    }
};

// Initialize Application
function initializeApp() {
    console.log('roomMic 2.0 - Starting application...');
    
    // Ensure only main screen is visible
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('active');
    });
    Elements.mainScreen.classList.add('active');
    
    // Bind event listeners
    Elements.btnCreateRoom.addEventListener('click', EventHandlers.createRoom);
    Elements.btnJoinRoom.addEventListener('click', EventHandlers.joinRoom);
    Elements.btnBackCreate.addEventListener('click', EventHandlers.backToMain);
    Elements.btnBackJoin.addEventListener('click', EventHandlers.backToMain);
    Elements.btnCopyCode.addEventListener('click', EventHandlers.copyRoomCode);
    Elements.btnStartHosting.addEventListener('click', EventHandlers.startHosting);
    Elements.btnJoinConfirm.addEventListener('click', EventHandlers.joinConfirm);
    Elements.btnToggleMic.addEventListener('click', EventHandlers.toggleMicrophone);
    Elements.btnLeaveRoom.addEventListener('click', EventHandlers.leaveRoom);

    // Numeric input only for room code
    Elements.joinCodeInput.addEventListener('input', (e) => {
        e.target.value = e.target.value.replace(/\D/g, '');
    });

    // Enter key for join
    Elements.joinCodeInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            EventHandlers.joinConfirm();
        }
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        ConnectionManager.cleanup();
        AudioManager.cleanup();
    });

    // Auto-resume audio context on user interaction
    document.addEventListener('click', () => {
        if (AppState.audioContext && AppState.audioContext.state === 'suspended') {
            AppState.audioContext.resume();
        }
    }, { once: true });

    // Keep-alive mechanism for connections
    setInterval(() => {
        if (AppState.peer && !AppState.peer.destroyed && AppState.peer.open) {
            // Send a heartbeat to keep connection alive
            console.log('Keep-alive: Connection active');
        }
    }, 30000); // Every 30 seconds

    console.log('roomMic 2.0 - Application initialized successfully!');
    Utils.showToast('roomMic 2.0  砖砖!');
}

// Start the application
document.addEventListener('DOMContentLoaded', initializeApp); 